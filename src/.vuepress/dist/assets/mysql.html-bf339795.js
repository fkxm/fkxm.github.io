import{_ as d}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as r,c as n,a as e,b as i,e as o,f as l}from"./app-60f9b323.js";const t={},h=l('<h2 id="having和where区别" tabindex="-1"><a class="header-anchor" href="#having和where区别" aria-hidden="true">#</a> having和where区别？</h2><ul><li><code>where</code>子句作用于表和视图，<code>having</code>作用于组。</li><li><code>where</code>在数据分组前进行过滤，<code>having</code>在数据分组后进行过滤。</li></ul><h2 id="myisam和innodb区别" tabindex="-1"><a class="header-anchor" href="#myisam和innodb区别" aria-hidden="true">#</a> MyISAM和InnoDB区别？</h2><ul><li>MyISAM： <ol><li>只支持表级锁（锁住整张表）；</li><li>不提供事务支持；</li><li>不支持外键；</li><li>不支持数据库异常崩溃后的安全恢复；</li></ol></li><li>InnoDB： <ol><li>支持行级锁和表级锁；</li><li>提供事务支持；</li><li>支持外键；</li><li>支持数据库异常崩溃后的安全恢复；</li></ol></li></ul><h2 id="何为-acid-特性-事务的特性-呢" tabindex="-1"><a class="header-anchor" href="#何为-acid-特性-事务的特性-呢" aria-hidden="true">#</a> 何为 ACID 特性（事务的特性）呢？</h2><ol><li>原子性 ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li>一致性： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li>隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li>持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响；</li></ol><h2 id="数据库事务的实现原理呢" tabindex="-1"><a class="header-anchor" href="#数据库事务的实现原理呢" aria-hidden="true">#</a> 数据库事务的实现原理呢？</h2><ul><li>MySQL InnoDB引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。</li><li>MySQL InnoDB引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <code>REPEATABLE-READ</code> ）。</li><li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li></ul><h2 id="并发事务带来哪些问题" tabindex="-1"><a class="header-anchor" href="#并发事务带来哪些问题" aria-hidden="true">#</a> 并发事务带来哪些问题?</h2><ul><li>脏读</li><li>幻读（与不可重复读类似，但是对表中查询的行数上的不一致）</li><li>不可重复读（某个值不一致）</li><li>丢失更新</li></ul><figure><img src="https://nevermore-picbed-1304219157.cos.ap-guangzhou.myqcloud.com/3_P-6PGQvztA.PNG" alt="第一类丢失更新" tabindex="0" loading="lazy"><figcaption>第一类丢失更新</figcaption></figure><figure><img src="https://nevermore-picbed-1304219157.cos.ap-guangzhou.myqcloud.com/4_Wo9k0u1K6s.PNG" alt="第二类丢失更新" tabindex="0" loading="lazy"><figcaption>第二类丢失更新</figcaption></figure><figure><img src="https://nevermore-picbed-1304219157.cos.ap-guangzhou.myqcloud.com/5_VWqDaFTIUw.PNG" alt="脏读" tabindex="0" loading="lazy"><figcaption>脏读</figcaption></figure><figure><img src="https://nevermore-picbed-1304219157.cos.ap-guangzhou.myqcloud.com/6_bBCIMzP68d.PNG" alt="不可重复读" tabindex="0" loading="lazy"><figcaption>不可重复读</figcaption></figure><figure><img src="https://nevermore-picbed-1304219157.cos.ap-guangzhou.myqcloud.com/7_3FEp_vn9QH.PNG" alt="幻读" tabindex="0" loading="lazy"><figcaption>幻读</figcaption></figure><h2 id="事务有哪些隔离级别" tabindex="-1"><a class="header-anchor" href="#事务有哪些隔离级别" aria-hidden="true">#</a> 事务有哪些隔离级别？</h2><ul><li>Read Uncommitted： 读未提交（级别最低）</li><li>Read Committed： 读已提交</li><li>Repeatable Read： 可重复读（默认）</li><li>Serializable： 串行化（级别最高，性能最低，因为要加锁）</li></ul><figure><img src="https://nevermore-picbed-1304219157.cos.ap-guangzhou.myqcloud.com/8_r3a8a_732R.PNG" alt="事务隔离级别" tabindex="0" loading="lazy"><figcaption>事务隔离级别</figcaption></figure><h2 id="数据库范式有哪些" tabindex="-1"><a class="header-anchor" href="#数据库范式有哪些" aria-hidden="true">#</a> 数据库范式有哪些？</h2><ul><li>1NF：属性不可再分。</li><li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li><li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li></ul><h2 id="drop、delete与-truncate-区别" tabindex="-1"><a class="header-anchor" href="#drop、delete与-truncate-区别" aria-hidden="true">#</a> drop、delete与 truncate 区别？</h2><ul><li>drop(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉。—— DDL(数据定义语言，不可回滚)</li><li>truncate (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。 ——DDL(数据定义语言，不可回滚)</li><li>delete（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一列的数据，如果不加 where 子句和<code>truncate table 表名</code>作用类似。 ——DML (数据库操作语言<code>增删改查</code>，可回滚)</li></ul><h2 id="mysql中的读有几种" tabindex="-1"><a class="header-anchor" href="#mysql中的读有几种" aria-hidden="true">#</a> MySQL中的读有几种？</h2>',23),u=e("li",null,[e("p",null,[i("一致性非锁定读（快照读，由MVCC实现）：在"),e("code",null,"可重复读"),i("和"),e("code",null,"读已提交"),i("隔离级别下触发，当读取一行值时，这一行刚好正在执行"),e("code",null,"删除"),i("或"),e("code",null,"更新"),i("操作时，不会因此去等待行上锁的释放，而是去读取该行版本的最新一个快照（即最新的历史版本）")])],-1),s=l("<p>一致性锁定读（当前读）：给行记录加 X （排它锁）或 S （共享锁）</p><ol><li><code>select...for update</code>：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</li><li><code>select...lock in share mode</code>：对记录加 <code>S</code> 锁，其它事务也可以加<code>S</code>锁，如果加 <code>x</code> 锁则会被阻塞</li></ol>",2),p={href:"https://www.cnblogs.com/cswiki/p/15307265.html",target:"_blank",rel:"noopener noreferrer"},g=l('<h2 id="mvcc-多版本并发控制-的实现原理-重点难点" tabindex="-1"><a class="header-anchor" href="#mvcc-多版本并发控制-的实现原理-重点难点" aria-hidden="true">#</a> MVCC(多版本并发控制)的实现原理？（重点难点）</h2><ul><li>隐藏字段 <ol><li><code>DB_TRX_ID``（6字节）</code>：记录事务id</li><li><code>DB_ROLL_PTR``（7字节）</code>：记录上一个版本数据记录的回滚指针</li><li><code>DB_ROW_ID``（6字节）</code>：隐含的自增ID，在没有设置主键的情况下使用该ID产生一个簇拥索引</li></ol></li><li>Read View（读视图）：快照读操作时生产的读视图</li><li>undo log（回滚日志） <ol><li><code>insert undo log</code></li><li><code>update undo log</code></li></ol></li></ul><h2 id="读已提交和可重复读隔离级别下-mvcc-的差异" tabindex="-1"><a class="header-anchor" href="#读已提交和可重复读隔离级别下-mvcc-的差异" aria-hidden="true">#</a> 读已提交和可重复读隔离级别下 MVCC 的差异？</h2><p><code>读已提交(RC)</code>：总是读取行的最新版本<code>Read View</code>；如果行被锁定了，非一致性读不会因此去等待行上锁的释放，而是去读取该行版本的最新一个快照（事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读）</p><p><code>可重复读(RR)</code>：总是读取事务开始时的行数据版本<code>Read View</code></p><h2 id="数据库索引类型有哪些" tabindex="-1"><a class="header-anchor" href="#数据库索引类型有哪些" aria-hidden="true">#</a> 数据库索引类型有哪些？</h2>',6),m={href:"https://segmentfault.com/a/1190000040177994",target:"_blank",rel:"noopener noreferrer"},f=l('<p>主键索引：</p><ul><li>一张数据表有只能有一个主键（可以不设主键），并且主键不能为 null，不能重复</li><li>若不设主键，如果有唯一索引，则选择该字段为默认的主键，否则会自动创建一个6Byte的自增主键</li></ul><p>唯一索引：</p><ul><li>索引列的值必须唯一，但允许有null，保证该属性数据唯一性</li><li>一张表允许创建多个唯一索引</li></ul><p>普通索引：</p><ul><li>一张表允许创建多个普通索引，允许数据重复和 NULL</li><li>唯一作用就是为了快速查询数据</li></ul><p>前缀索引：</p><ul><li>只适用于字符串类型的数据</li><li>只取文本前几个字符创建索引</li></ul><p>全文索引：</p><ul><li>检索大文本数据中的关键字</li></ul><h2 id="mysql-聚集索引和非聚集索引区别" tabindex="-1"><a class="header-anchor" href="#mysql-聚集索引和非聚集索引区别" aria-hidden="true">#</a> MySQL 聚集索引和非聚集索引区别？</h2><p>聚集索引：索引结构和数据一起存放的索引，是一种数据存储方式。主键索引属于聚集索引。</p><p>非聚集索引：二级索引（唯一索引，普通索引，前缀索引等）属于非聚集索引。</p><p>相同点:</p><ul><li>内部都是 B+ 树</li></ul><p>不同点：</p><ul><li>聚集索引的叶子节点存放是一整行数据（数据、索引放一块）；非聚集索引的叶子节点存储主键的值</li><li>聚集索引一个表只能有一个；非聚集索引一个表可以存在多个</li><li>聚集索引存储记录是物理上连续存在；非聚集索引是逻辑上的连续</li><li>聚集索引查询数据速度快，插入数据速度慢；非聚集索引反之，可能会二次查询（回表）</li></ul><h2 id="非聚集索引一定回表查询吗-覆盖索引" tabindex="-1"><a class="header-anchor" href="#非聚集索引一定回表查询吗-覆盖索引" aria-hidden="true">#</a> 非聚集索引一定回表查询吗(覆盖索引)?</h2><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p><p>覆盖索引：需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询（概括：查询的正好是索引—主键索引、唯一索引、普通索引等）</p><p><code>如：select id from table where id = 1</code></p><h2 id="索引的优缺点" tabindex="-1"><a class="header-anchor" href="#索引的优缺点" aria-hidden="true">#</a> 索引的优缺点</h2><p>优点 ：</p><ul><li>使用索引可以加快数据的检索速度（大大减少检索的数据量）</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p>缺点 ：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><h2 id="b树和b-树的区别" tabindex="-1"><a class="header-anchor" href="#b树和b-树的区别" aria-hidden="true">#</a> B树和B+树的区别？</h2><p>注意：MySQL默认使用B+树</p><ul><li>B 树的所有节点既存放键(key) 也存放 数据(data)；而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><figure><img src="https://nevermore-picbed-1304219157.cos.ap-guangzhou.myqcloud.com/1.PNG" alt="B+树" tabindex="0" loading="lazy"><figcaption>B+树</figcaption></figure>',30);function b(_,y){const a=c("ExternalLinkIcon");return r(),n("div",null,[h,e("ul",null,[u,e("li",null,[s,e("p",null,[i("参考："),e("a",p,[i("https://www.cnblogs.com/cswiki/p/15307265.html"),o(a)])])])]),g,e("p",null,[i("参考："),e("a",m,[i("https://segmentfault.com/a/1190000040177994"),o(a)])]),f])}const v=d(t,[["render",b],["__file","mysql.html.vue"]]);export{v as default};
