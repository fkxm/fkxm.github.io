import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as d,o as r,c,a as e,b as i,e as l,f as a}from"./app-60f9b323.js";const n={},T=a('<p>超文本传输协议（HTTP，HyperText Transfer Protocol）是一个用于传输超媒体文档（例如 HTML）的应用层协议。</p><p>HTTP 是无状态的协议，无法记录客户端用户的状态。</p><h2 id="响应状态码" tabindex="-1"><a class="header-anchor" href="#响应状态码" aria-hidden="true">#</a> 响应状态码</h2><p>响应状态码分为五大类：</p><table><thead><tr><th>分类</th><th>描述</th></tr></thead><tbody><tr><td>1xx</td><td>信息</td></tr><tr><td>2xx</td><td>成功</td></tr><tr><td>3xx</td><td>重定向</td></tr><tr><td>4xx</td><td>客户端错误</td></tr><tr><td>5xx</td><td>服务器错误</td></tr></tbody></table><p>常见状态码：</p><ul><li>100（继续）：客户端应继续其请求</li><li>200（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页</li><li>201（已创建） 请求成功并且服务器创建了新的资源</li><li>202（已接受） 服务器已接受请求，但尚未处理</li><li>301（永久重定向） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</li><li>302（临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li>304（资源未修改）客户端请求的数据还是最新的，服务器不再返回数据</li><li>403（禁止） 请求的资源被禁止，服务器拒绝请求</li><li>404（未找到） 请求的资源不存在，服务器找不到请求的网页</li><li>500（服务器内部错误）：服务器遇到错误，无法完成请求</li><li>502（错误网关）：服务器作为网关或代理，但是从上游服务器得到错误响应。常见于：客户端访问服务器某个防火墙没有开放的接口</li><li>503 （服务不可用）：服务器因维护或过载而停机，通常只是暂时的，应返回解释当前问题的页面</li><li>504 （网关超时）：服务器作为网关或代理，但是没有及时从上游服务器收到请求</li></ul><h2 id="http-header" tabindex="-1"><a class="header-anchor" href="#http-header" aria-hidden="true">#</a> HTTP header</h2><p>请求头 Request Headers:</p><ul><li>Accept：浏览器可接收的数据格式</li><li>Accept-Encoding：浏览器可接收的压缩算法，如 gzip</li><li>Accept-Languange：浏览器可接收的语言，如 zh-CN</li><li>Connection：keep-alive 一次 TCP 连接重复使用</li><li>cookie</li><li>Host：域名</li><li>User-Agent：浏览器信息</li><li>Content-type：发送数据的格式，如 application/json</li></ul><p>响应头 Response Headers:</p><ul><li>Ccontent-type：返回数据的格式，如 application/json</li><li>Content-length：返回数据的大小（字节）</li><li>Content-Encoding：返回数据的压缩算法，如 gzip</li></ul><h2 id="http1-与-http2" tabindex="-1"><a class="header-anchor" href="#http1-与-http2" aria-hidden="true">#</a> HTTP1 与 HTTP2</h2><p>HTTP1 与 HTTP2 的区别：</p><ol><li>HTTP/2 使用二进制传输，将 header 和 body 分成帧来传输。HTTP/1.1 是字符串传输。</li><li>HTTP/2 支持<strong>多路复用</strong>，速度快，延迟低。HTTP/1.1 不支持。</li><li>HTTP/2 支持<strong>头部压缩</strong>，HTTP/1.1 不支持。</li><li>HTTP/2 支持<strong>服务器推送</strong>， HTTP/1.1 不支持。</li></ol><h2 id="https" tabindex="-1"><a class="header-anchor" href="#https" aria-hidden="true">#</a> HTTPS</h2><p>HTTPS = HTTP + SSL/TLS(安全层)</p><p>TLS（Transport Layer Security，安全传输层协议），前身是 SSL（Secure Socket Layer，安全套接字协议）</p><ul><li>对称加密：客户端和服务端使用相同的秘钥进行加密解密。优点：速度快；缺点：服务端需要保存很多个客户端的密钥，并保证不被泄露。</li><li>非对称加密：也称为公钥加密。服务端拥有一对可以互相加密解密的公钥和私钥，服务端在网络上任意分发公钥，客户端用公钥加密数据后，再发给服务端。缺点：速度慢</li><li>混合加密：同时使用对称加密和非对称加密，平衡两者的优缺点。</li></ul><p>TLS 使用了对称加密、非对称加密、身份认证等技术。</p><h3 id="tls1-2-握手过程" tabindex="-1"><a class="header-anchor" href="#tls1-2-握手过程" aria-hidden="true">#</a> TLS1.2 握手过程</h3><p>握手过程：</p><ol><li>客户端向服务端发送第1随机数，服务端收到后再发送第2随机数、公钥和证书，客户端比对服务端发放的公钥是否通过证书颁发机构（CA）的认证；</li><li>客户端再生成第3随机数（预主密钥）通过公钥加密发送，服务端收到后通过自己的私钥进行解密，得到预主密钥；</li><li>客户端和服务端都通过第1随机数、第2随机数和预主密钥计算出会话秘钥，后续就使用会话秘钥进行加密通信。</li></ol><p>TLS1.2 使用了对称加密、非对称加密、身份认证等技术：</p><ul><li>身份认证：客户端比对服务端发放的公钥是否通过证书颁发机构（CA）的认证</li><li>非对称加密：客户端发送公钥给客户端加密第3随机数（预主密钥），再通过私钥解密得到第3随机数。</li><li>对称加密：客户端和服务端都持有相同的会话秘钥（第1随机数 + 第2随机数 + 第3随机数）</li></ul><h3 id="http-与-https-的区别" tabindex="-1"><a class="header-anchor" href="#http-与-https-的区别" aria-hidden="true">#</a> HTTP 与 HTTPS 的区别</h3><ol><li><code>HTTP</code> 是明文传输的，不安全；<code>HTTPS</code> 是加密传输的，非常安全。</li><li><code>HTTP</code> 使用 80 端口，<code>HTTPS</code> 使用 443 端口。</li><li><code>HTTP</code> 较快，<code>HTTPS</code> 较慢。</li><li><code>HTTPS</code> 的 CA 证书需要购买（但也有免费的），<code>HTTP</code> 不需要证书。</li></ol><h2 id="get-与-post-的区别" tabindex="-1"><a class="header-anchor" href="#get-与-post-的区别" aria-hidden="true">#</a> GET 与 POST 的区别</h2><p>协议规定的根本区别：HTTP 协议规定的语义上获取数据与提交数据的区别</p><p>工程实践中的区别：</p><ul><li><code>GET</code> 用于获取数据，无副作用，幂等，请求参数一般放在 URL 里，可缓存，产生一个 TCP 数据包。</li><li><code>POST</code> 用于提交数据，有副作用，非幂等，请求参数一般放在请求体中，不可缓存，产生两个或以上 TCP 数据包。</li></ul><p>(幂等表示执行相同的操作，结果也是相同的)</p><p>详细区别：</p><ul><li>从<strong>缓存</strong>的角度，<code>GET</code> 请求会被浏览器主动缓存下来，留下历史记录，而 <code>POST</code> 默认不会。</li><li>从<strong>编码</strong>的角度，<code>GET</code> 只能进行 <code>URL</code> 编码，只能接收 <code>ASCII</code> 字符，而 <code>POST</code> 没有限制。</li><li>从<strong>参数</strong>的角度，<code>GET</code> 一般放在 <code>URL</code> 中，因此不安全，<code>POST</code> 放在请求体中，更适合传输敏感信息。</li><li>从<strong>幂等性</strong>的角度，<code>GET</code> 是幂等的，而 <code>POST</code> 不是。</li><li>从 <strong>TCP</strong> 的角度，<code>GET</code> 请求会把请求报文一次性发出去。而 <code>POST</code> 会分为两个 <code>TCP</code> 数据包：首先发 <code>header</code> 部分，如果服务器响应 <code>100(continue)</code>， 再发 <code>body</code> 部分。</li></ul><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',35),h={href:"https://www.bilibili.com/video/BV1KY411x7Jp",target:"_blank",rel:"noopener noreferrer"},s={href:"https://www.bilibili.com/video/BV1M44y1175D",target:"_blank",rel:"noopener noreferrer"};function p(P,H){const t=d("ExternalLinkIcon");return r(),c("div",null,[T,e("ul",null,[e("li",null,[e("a",h,[i("HTTPS是什么？加密原理和证书。SSL/TLS握手过程"),l(t)])]),e("li",null,[e("a",s,[i("搞懂HTTPS工作原理"),l(t)])])])])}const g=o(n,[["render",p],["__file","http.html.vue"]]);export{g as default};
