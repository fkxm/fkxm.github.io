import{_ as d}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as r,c,a as e,b as o,e as a,f as l}from"./app-60f9b323.js";const n={},h=l('<p>HTTP 缓存是浏览器对之前请求过的文件进行缓存，以便下次访问时重复使用，减少网络请求次数，提高页面加载速度，缓解服务端的压力。<br> HTTP 缓存分为：强制缓存与协商缓存</p><figure><img src="https://nevermore-picbed-1304219157.cos.ap-guangzhou.myqcloud.com/20220506030900.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="强制缓存" tabindex="-1"><a class="header-anchor" href="#强制缓存" aria-hidden="true">#</a> 强制缓存</h2><h3 id="定义与过程" tabindex="-1"><a class="header-anchor" href="#定义与过程" aria-hidden="true">#</a> 定义与过程</h3><p>定义：客户端向服务端发送首次请求，服务端返回带有 <code>Cache-Control</code> 或 <code>Expires</code> 字段控制资源过期时间的响应。在过期时间内客户端不再重复发送请求，直接读取客户端本地缓存。</p><p>过程：</p><ul><li>客户端向服务端发送首次请求，服务端返回带有 <code>Cache-Control</code> 或 <code>Expires</code> 字段的资源。</li><li>后续请求时，如果资源没有过期（强制缓存生效）：直接从浏览器本地缓存中获取资源，状态码 <code>200 OK (from memory cache)</code>。</li><li>后续请求时，如果资源过期（强制缓存失效）：在没有使用协商缓存的情况下会重复首次请求的步骤。所以一般会搭配使用协商缓存。</li></ul><p>控制强制缓存的字段有：</p><ul><li><code>Pragma</code>（不推荐使用）</li><li><code>Expires</code>（HTTP/1.0）</li><li><code>Cache-Control</code>（HTTP/1.1）</li></ul><h3 id="expires-与-cache-control" tabindex="-1"><a class="header-anchor" href="#expires-与-cache-control" aria-hidden="true">#</a> Expires 与 Cache-Control</h3><p><code>Expires</code> 过期时间。缺点在于该日期依赖的是用户的系统时间，如果用户系统时间不准确，缓存有效期就不准确。</p><p><code>Cache-Control</code> 缓存控制。在请求头和响应头中都可以使用，常用的属性有：</p><ul><li>max-age： 最大缓存时间（秒）</li><li>no-cache：不使用强缓存，需要向服务器验证缓存是否是最新的</li><li>no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源</li><li>public：响应可以被中间代理、CDN 等缓存</li><li>private：仅客户端可以缓存数据，代理服务器、CDN 不可缓存</li><li>must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证</li></ul><p>优先级：<code>Cache-Control</code> 的优先级比 <code>Expires</code> 高。</p><h2 id="协商缓存-对比缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存-对比缓存" aria-hidden="true">#</a> 协商缓存（对比缓存）</h2><h3 id="定义与过程-1" tabindex="-1"><a class="header-anchor" href="#定义与过程-1" aria-hidden="true">#</a> 定义与过程</h3><p>定义：强制缓存失效后，客户端携带资源标识向服务端发送请求。服务端根据资源标识判断缓存资源与最新资源是否相同，告诉客户端是否使用缓存资源。</p><p>过程：</p><ul><li>客户端向服务端发送首次请求时，服务端返回资源文件和资源标识（携带有 <code>Last-Modified</code> 或 <code>Etag</code> 的响应）。</li><li>后续请求时，客户端发送携带 <code>If-Modified-Since</code> 或 <code>If-None-Match</code> 的请求。（值分别与首次请求的 <code>Last-Modified</code> 或 <code>Etag</code> 相等）</li><li>服务端根据两者是否相等判断资源是否没有更新：<br> 如果相等（协商缓存生效），则返回 304 状态码，告诉客户端使用本地缓存。<br> 如果不相等（协商缓存失效），则返回 200 状态码，并返回最新的资源文件和资源标识。</li></ul><p>控制协商缓存的字段有：</p><ul><li><code>Last-Modified/If-Modified-Since</code>（HTTP/1.0）</li><li><code>Etag/If-None-Match</code>（HTTP/1.1）</li></ul><h3 id="etag-与-last-modified" tabindex="-1"><a class="header-anchor" href="#etag-与-last-modified" aria-hidden="true">#</a> Etag 与 Last-Modified</h3><p><code>Last-Modified/If-Modified-Since</code> 最后修改时间，某个资源文件在服务器最后被修改时间。缺点在于精度只到秒级，1 秒内的多次修改无法判断资源是否更新。</p><p><code>Etag/If-None-Match</code> 资源标识，服务端根据资源文件的内容生成的唯一资源标识。</p><p>优先级：<code>Etag/If-None-Match</code>优先级比<code>Last-Modified/If-Modified-Since</code>高。</p><h2 id="三种刷新操作对缓存的影响" tabindex="-1"><a class="header-anchor" href="#三种刷新操作对缓存的影响" aria-hidden="true">#</a> 三种刷新操作对缓存的影响</h2><ul><li>正常操作（<strong>强制缓存有效，协商缓存有效</strong>）：地址栏输入 <code>URL</code>，跳转链接，前进后退等</li><li>手动刷新（<strong>强制缓存失效，协商缓存有效</strong>）：<code>F5</code>，点击工具栏中的刷新按钮，右键菜单重新加载</li><li>强制刷新（<strong>强制缓存失效，协商缓存失效</strong>）：<code>Ctrl+F5</code>，<code>Shift+Command+R</code></li></ul><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">强制缓存</th><th style="text-align:center;">协商缓存</th></tr></thead><tbody><tr><td style="text-align:center;">正常操作</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td></tr><tr><td style="text-align:center;">手动刷新</td><td style="text-align:center;">❌</td><td style="text-align:center;">✅</td></tr><tr><td style="text-align:center;">强制刷新</td><td style="text-align:center;">❌</td><td style="text-align:center;">❌</td></tr></tbody></table><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',29),s={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control",target:"_blank",rel:"noopener noreferrer"},p={href:"https://zhuanlan.zhihu.com/p/143064070",target:"_blank",rel:"noopener noreferrer"},f={href:"https://juejin.cn/post/6844903838768431118",target:"_blank",rel:"noopener noreferrer"},g={href:"https://www.bilibili.com/video/BV17Q4y127We?p=1",target:"_blank",rel:"noopener noreferrer"};function u(x,_){const t=i("ExternalLinkIcon");return r(),c("div",null,[h,e("ul",null,[e("li",null,[e("a",s,[o("Cache-Control —— MDN"),a(t)])]),e("li",null,[e("a",p,[o("HTTP缓存之协商缓存和强制缓存"),a(t)])]),e("li",null,[e("a",f,[o("http面试必会的：强制缓存和协商缓存"),a(t)])]),e("li",null,[e("a",g,[o("HTTP 缓存【JS面试题小合集】"),a(t)])])])])}const C=d(n,[["render",u],["__file","http-cache.html.vue"]]);export{C as default};
